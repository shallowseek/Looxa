 see exactly why you’re still getting

kotlin
Copy
Edit
this is the x  null and y coordinates 0 in frame
even after tapping — it’s not because useRef is wrong, but because of how VisionCamera frame processors work.

1️⃣ The problem
useFrameProcessor worklet runs on the UI thread, completely separate from the JS thread.

tapX.current and tapY.current are being updated on the JS thread when you tap.

But the UI-thread worklet does not automatically see those updates, because normal JS variables/refs aren’t shared across threads.

That’s why even after you set tapX.current = 100 in onTapJS,
the frame processor is still reading the old value (which is null).

2️⃣ Why this happens
VisionCamera’s frame processors are “frozen” snapshots — they don’t get live access to JS memory.
When you write:

js
Copy
Edit
const fProcessor = useFrameProcessor((frame) => { 'worklet'; ... }, []);
that function is serialized and sent to the UI thread.
It can only read:

The frame data (from VisionCamera)

Worklet-safe constants and functions

Values passed in as dependencies

It cannot read a useRef’s .current if that ref is mutated on the JS thread — they are separate memory spaces.

3️⃣ How to fix
You need to send the tap coordinates into the UI thread in a way that the worklet can access.
Two common solutions:

Option 1 — Use a Reanimated shared value
Shared values are thread-safe and sync between JS thread & UI thread:

js
Copy
Edit
import { useSharedValue } from 'react-native-reanimated';

const tapX = useSharedValue(null);
const tapY = useSharedValue(null);

const onTapJS = (x, y) => {
  tapX.value = x;
  tapY.value = y;
};

const fProcessor = useFrameProcessor((frame) => {
  'worklet';
  if (tapX.value == null || tapY.value == null) return;

  const scale_X = frame.width / previewWidth;
  const scale_Y = frame.height / previewHeight;

  const frameCoord_X = Math.floor(tapX.value * scale_X);
  const frameCoord_Y = Math.floor(tapY.value * scale_Y);

  console.log("this is the x", tapX.value, "and y", frameCoord_Y, "in frame");
}, [previewHeight, previewWidth, tapX, tapY]);
✅ Now updates to tapX.value and tapY.value are visible inside the worklet immediately.

Option 2 — Pass coordinates as dependencies
If you keep them in state instead of useRef:

js
Copy
Edit
const [tapX, setTapX] = useState(null);
const [tapY, setTapY] = useState(null);

const onTapJS = (x, y) => {
  setTapX(x);
  setTapY(y);
};

const fProcessor = useFrameProcessor((frame) => { 'worklet';
  if (tapX == null || tapY == null) return;
  ...
}, [tapX, tapY, previewHeight, previewWidth]);
⚠ This works but recreates the frame processor every tap — so less performant than shared values.

4️⃣ Why useRef doesn’t help here
useRef only persists a value across re-renders in the JS thread.
Your frame processor is not running in that same memory space, so it never sees .current updates — unless you re-create the worklet with new dependencies (which we’re avoiding for performance).

If you want, I can rewrite your code using shared values so tapping instantly updates the coordinates inside the worklet without recreating it every time.
That’s the cleanest VisionCamera pattern.









Ask ChatGPT
